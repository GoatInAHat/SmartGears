<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
  <meta content="concept" name="topic-type"/>
  <meta content="/view/OARX/2025/ENU/" name="helpsystempath"/>
  <meta content="OARX" name="product"/>
  <meta content="2025" name="release"/>
  <meta content="Developer" name="book"/>
  <meta content="AutoCAD-AutoLISP-Tutorials" name="component"/>
  <meta content="25/4/2024" name="created"/>
  <meta content="ACD=2025" name="applies-to"/>
  <meta content="ACAD_E=2025" name="applies-to"/>
  <meta content="AMECH_PP=2025" name="applies-to"/>
  <meta content="ARCHDESK=2025" name="applies-to"/>
  <meta content="BLDSYS=2025" name="applies-to"/>
  <meta content="CIV3D=2025" name="applies-to"/>
  <meta content="MAP=2025" name="applies-to"/>
  <meta content="PLNT3D=2025" name="applies-to"/>
  <meta content="PNID=2025" name="applies-to"/>
  <meta content="STRDET=2025" name="applies-to"/>
  <meta content="UTLDESN=2025" name="applies-to"/>
  <meta content="CSY, DEU, ESP, FRA, HUN, ITA, KOR, PLK, PTB, RUS, CHS, CHT" name="applies-to-languages"/>
  <meta content="TRIDION" name="generatedby"/>
  <meta content="disable" name="user-comments"/>
  <meta content="GUID-EA2B760C-866D-46BB-B682-EEC46C8FF11B" name="workflow-parent-id"/>
  <meta content="general" name="experiencelevel"/>
  <meta content="programmer" name="audience"/>
  <meta content="02/12/2019" name="modified"/>
  <meta content="autolisp" name="topic-subtype"/>
  <meta content="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7" name="topicid"/>
  <meta content="ENU" name="language"/>
  <title>
   Planning the Callback Functions
  </title>
  <link href="../../../../_assets/client-28da4093.css" rel="stylesheet" type="text/css"/>
 </head>
 <body id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7">
  <div class="head">
   <div class="head-block">
    <div class="button-info">
     <span id="infoline">
     </span>
    </div>
    <div class="ancestry">
    </div>
    <div class="head-text">
     <h1>
      Planning the Callback Functions
     </h1>
    </div>
   </div>
  </div>
  <div class="body conbody">
   <div class="section" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__GUID-DF4D2FCB-83E8-4A31-962A-46A915C208FF">
    <p class="p" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__WSFACF1429558A55DE1929BBDFEF458CE1C-76F1">
     For each reactor event, you must plan the function that will be invoked when the event occurs. The following pseudo-code outlines the logical sequence of events that should occur when users drag one of the polyline vertices to a new location:
    </p>
    <pre class="pre codeblock prettyprint">Defun gp:outline-changed
       Erase the tiles.
       Determine how the boundary changed.
       Straighten up the boundary.
       Redraw new tiles.
End function</pre>
    <p class="p" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__WSFACF1429558A55DE1929BBDFEF458CE1C-76F0">
     There is a complication, though. When the user begins dragging the outline of a polyline vertex, AutoCAD notifies your application by issuing a
     <samp class="ph codeph" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__GUID-0D552B3C-BD0C-499F-A966-81C040371D81">
      :vlr-modified
     </samp>
     event. However, at this point the user has just begun dragging one of the polyline vertices. If you immediately invoke the
     <samp class="ph codeph" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__GUID-DFE410E3-6737-419C-A32D-51F1870FDD7A">
      gp:outline-changed
     </samp>
     function, you will interrupt the action that the user is in the midst of. You would not know where the new vertex location will be, because the user has not yet selected its position. And finally, AutoCAD will not allow your function to modify the polyline object while the user is still dragging it. AutoCAD has the polyline object open for modification, and leaves it open until the user finishes repositioning the object.
    </p>
    <p class="p" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__WSFACF1429558A55DE1929BBDFEF458CE1C-76EF">
     You need to change your approach. Here is the updated logic:
    </p>
    <pre class="pre codeblock prettyprint">When the user begins repositioning a polyline vertex,
  Invoke the gp:outline-changed function
  Defun gp:outline-changed
    Set a global variable that stores a pointer to the polyline
    being modified by the user
  End function

When the command completes,
  Invoke the gp:command-ended function
  Defun gp:command-ended
           Erase the tiles
           Get information on the previous polyline vertex locations
           Get information on the new polyline vertex locations
           Redefine the polyline (straighten it up)
           Redraw the tiles
  End function</pre>
    <p class="p" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__WSFACF1429558A55DE1929BBDFEF458CE1C-76EE">
     When a user completes modifying a path outline, AutoCAD notifies your application by issuing a
     <samp class="ph codeph" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__GUID-AFE7A1F4-E44D-4D5B-9653-CF96ADAF35DB">
      :vlr-commandEnded
     </samp>
     event, if you have established an editor reactor.
    </p>
    <p class="p" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__WSFACF1429558A55DE1929BBDFEF458CE1C-76ED">
     The use of a global variable to identify the polyline the user changed is necessary because there is no continuity between the
     <samp class="ph codeph" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__GUID-E10495BB-3B86-40EA-B090-9DFD7F0950A7">
      gp:outline-changed
     </samp>
     and
     <samp class="ph codeph" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__GUID-377E4FDE-6E69-4653-8DD0-142DFF00A305">
      gp:command-ended
     </samp>
     functions. In your application, both functions are invoked and executed independently of one another. The global variable stores important information set up in one function and accessed in the other.
    </p>
    <p class="p" id="GUID-BB44D330-083B-45F7-B1FA-06B47C2465D7__WSFACF1429558A55DE1929BBDFEF458CE1C-76EC">
     Now consider what to do if the user erases the garden path boundary. The ultimate objective is to erase all the tiles. The following pseudo-code outlines the logic:
    </p>
    <pre class="pre codeblock prettyprint">When the user begins to erase the boundary,
  Invoke the gp:outline-erased function
  Defun gp:outline-erased
     Set a global variable that stores a pointer to the reactor
     attached to the polyline currently being erased
  End function

When the erase is completed,
  Invoke the gp:command-ended function
  Defun gp:command-ended
     Erase the tiles that belonged to the now-deleted polyline
  End function</pre>
   </div>
  </div>
  <div class="related-links">
   <div class="familylinks">
    <div class="parentlink">
     <strong>
      Parent topic:
     </strong>
     <a class="link" href="Lesson_6_Acting_With_Reactors_Visual_LISP_IDE.html">
      Lesson 6: Acting With Reactors (Visual LISP IDE)
     </a>
    </div>
    <div class="previouslink">
     <strong>
      Previous topic:
     </strong>
     <a class="link" href="Selecting_Reactor_Events_for_the_Garden_Path.html">
      Selecting Reactor Events for the Garden Path
     </a>
    </div>
    <div class="nextlink">
     <strong>
      Next topic:
     </strong>
     <a class="link" href="Planning_for_Multiple_Reactors.html">
      Planning for Multiple Reactors
     </a>
    </div>
   </div>
  </div>
 </body>
</html>
