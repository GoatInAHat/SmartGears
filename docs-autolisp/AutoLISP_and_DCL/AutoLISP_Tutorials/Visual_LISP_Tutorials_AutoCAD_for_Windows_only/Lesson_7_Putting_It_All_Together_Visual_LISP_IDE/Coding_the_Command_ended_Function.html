<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
  <meta content="concept" name="topic-type"/>
  <meta content="/view/OARX/2025/ENU/" name="helpsystempath"/>
  <meta content="OARX" name="product"/>
  <meta content="2025" name="release"/>
  <meta content="Developer" name="book"/>
  <meta content="AutoCAD-AutoLISP-Tutorials" name="component"/>
  <meta content="25/4/2024" name="created"/>
  <meta content="ACD=2025" name="applies-to"/>
  <meta content="ACAD_E=2025" name="applies-to"/>
  <meta content="AMECH_PP=2025" name="applies-to"/>
  <meta content="ARCHDESK=2025" name="applies-to"/>
  <meta content="BLDSYS=2025" name="applies-to"/>
  <meta content="CIV3D=2025" name="applies-to"/>
  <meta content="MAP=2025" name="applies-to"/>
  <meta content="PLNT3D=2025" name="applies-to"/>
  <meta content="PNID=2025" name="applies-to"/>
  <meta content="STRDET=2025" name="applies-to"/>
  <meta content="UTLDESN=2025" name="applies-to"/>
  <meta content="CSY, DEU, ESP, FRA, HUN, ITA, KOR, PLK, PTB, RUS, CHS, CHT" name="applies-to-languages"/>
  <meta content="TRIDION" name="generatedby"/>
  <meta content="disable" name="user-comments"/>
  <meta content="GUID-209318DE-95C4-40F6-8776-935C8905FDEE" name="workflow-parent-id"/>
  <meta content="general" name="experiencelevel"/>
  <meta content="programmer" name="audience"/>
  <meta content="02/12/2019" name="modified"/>
  <meta content="autolisp" name="topic-subtype"/>
  <meta content="GUID-B01C9105-4ECD-4C3F-AED2-5B5A53966C61" name="topicid"/>
  <meta content="ENU" name="language"/>
  <title>
   Coding the Command-ended Function
  </title>
  <link href="../../../../_assets/client-28da4093.css" rel="stylesheet" type="text/css"/>
 </head>
 <body id="GUID-B01C9105-4ECD-4C3F-AED2-5B5A53966C61">
  <div class="head">
   <div class="head-block">
    <div class="button-info">
     <span id="infoline">
     </span>
    </div>
    <div class="ancestry">
    </div>
    <div class="head-text">
     <h1>
      Coding the Command-ended Function
     </h1>
    </div>
   </div>
  </div>
  <div class="body conbody">
   <div class="section" id="GUID-B01C9105-4ECD-4C3F-AED2-5B5A53966C61__GUID-8C56442D-E36A-4D9E-AEA0-EE198607E886">
    <p class="p" id="GUID-B01C9105-4ECD-4C3F-AED2-5B5A53966C61__WSFACF1429558A55DE1929BBDFEF458CE1C-7875">
     Now that you have seen the pseudo-code and handled some important details, replace the stubbed-out code in the
     <samp class="ph codeph" id="GUID-B01C9105-4ECD-4C3F-AED2-5B5A53966C61__GUID-48DAAC5D-A516-46EC-A833-CA0044F989E2">
      gp:command-ended
     </samp>
     reactor callback with the following:
    </p>
    <pre class="pre codeblock prettyprint">(defun gp:command-ended (reactor command-list
                         / objReactor
                         reactorToChange reactorData
                         coordinateValues currentPoints
                         newReactorData newPts
                         tileList
                         )
  (cond
    ;; CONDITION 1 - POLYLINE ERASED (Erase command)
    ;; If one or more polyline borders are being erased (indicated
    ;; by the presence of *reactorsToRemove*), erase the tiles
    ;; within the border, then remove the reactor.
    (*reactorsToRemove*
      (foreach objReactor *reactorsToRemove*
        (gp:erase-tiles objReactor)
      )
      (setq *reactorsToRemove* nil)
    )

    ;; CONDITION 2 - LOST ASSOCIATIVITY (Move, Rotate, etc.)
    ;; If associativity has been lost (undo, move, etc.), then
    ;; erase the tiles within each border
    ;; 
    ((and *lostassociativity* *reactorsToChange*)
      (foreach reactorToChange *reactorsToChange*
        (gp:erase-tiles reactorToChange)
      )
      (setq *reactorsToChange* nil)
    )

    ;; CONDITION 3 - GRIP_STRETCH 
    ;; In this case, the associativity of the tiles to the path is
    ;; kept, but the path and the tiles will need to be
    ;; recalculated and redrawn. A GRIP_STRETCH can only be
    ;; performed on a single POLYLINE at a time.
    ((and (not *lostassociativity*)
      *polytochange*
      *reactorsToChange*
      (member "GRIP_STRETCH" command-list)
      ;; for a GRIP_STRETCH, there will be only one reactor in
      ;; the global *reactorsToChange*.
      (setq reactorData
         (vlr-data (setq reactorToChange
                  (car *reactorsToChange*)
                 )
               )
        )
     )

     ;; First, erase the tiles within the polyline border.
     (gp:erase-tiles reactorToChange)

     ;; Next, get the current coordinate values of the polyline
     ;; vertices.
     (setq coordinateValues
       (vlax-safearray-&gt;list
         (vlax-variant-value
           (vla-get-coordinates *polyToChange*)
         )
       )
     )

     ;; If the outline is a lightweight polyline, you have
     ;; 2d points, so use utility function xyList-&gt;ListOfPoints
     ;; to convert the coordinate data into lists of
     ;; ((x y) (x y) ...) points. Otherwise, use the
     ;; xyzList-&gt;ListOfPoints function that deals
     ;; with 3d points, and converts the coordinate data into
     ;; lists of ((x y z) (x y z) ... ) points.
     (setq CurrentPoints
        (if (= (vla-get-ObjectName *polytochange*) "AcDbPolyline")
          (xyList-&gt;ListOfPoints coordinateValues)
          (xyzList-&gt;ListOfPoints coordinateValues)
        )
     )

     ;; Send this new information to RedefinePolyBorder -- this
     ;; will return the new Polyline Border
     (setq NewReactorData
       (gp:RedefinePolyBorder CurrentPoints reactorData)
     )

     ;; Get all the border Points and ...
     (setq newpts
            (list
              (cdr (assoc 12 NewReactorData))
              (cdr (assoc 13 NewReactorData))
              (cdr (assoc 14 NewReactorData))
              (cdr (assoc 15 NewReactorData))
            )
     )

     ;; ...update the outline of the polyline with the new points
     ;; calculated above.  If dealing with a lightweight polyline,
     ;; convert these points to 2D (since all the points in
     ;; newpts are 3D), otherwise leave them alone.
     (if (= (cdr (assoc 4 NewReactorData)) "LIGHT")
       (setq newpts (mapcar '(lambda (point)
                        (3dPoint-&gt;2dPoint Point)
                      )
                      newpts
                    )
       )
     )

     ;; Now update the polyline with the correct points.
     (vla-put-coordinates
       *polytochange*

       ;; For description of the list-&gt;variantArray see utils.lsp.
       (gp:list-&gt;variantArray (apply 'append newpts))
     )

     ;; Now use the current definition of the NewReactorData, 
     ;; which is really the same as the garden path data
     ;; structure. The only exception is that the field (100) 
     ;; containing the list of tiles is nil.  This is OK since
     ;; gp:Calculate-and-Draw-Tiles does not require this field 
     ;; to draw the tiles. In fact this function creates the tiles
     ;; and returns a list of drawn tiles.
     (setq tileList (gp:Calculate-and-Draw-Tiles
              ;; path data list without correct tile list
              NewReactorData
              ;; Object creation function
              ;; Within a reactor this *MUST* be ActiveX
              "ActiveX"
              )
     )

     ;; Now that you have received all the tiles drawn, rebuild
     ;; the data structure with the correct tileList value and
     ;; reset the data property in the reactor.
     ;; Update the tiles associated with the polyline border.
     (setq NewReactorData
        (subst (cons 100 tileList)
           (assoc 100 NewReactorData)
           NewReactorData
           )
     )

     ;; By now you have the new data associated with the polyline.
     ;; All there is left to do is associate it with the reactor
     ;; using vlr-data-set.
     (vlr-data-set (car *reactorsToChange*) NewReactorData)

     ;; Remove all references to the temporary
     ;; variables *polytochange* and *reactorsToChange*.
     (setq *polytochange*     nil
       *reactorsToChange* nil
       )
     )
    )
    ;; Delete any items in the *Safe-to-Delete* global if you can!!!
    (Gp:Safe-Delete (car command-list))
   (princ)
 )</pre>
   </div>
  </div>
  <div class="related-links">
   <div class="familylinks">
    <div class="parentlink">
     <strong>
      Parent topic:
     </strong>
     <a class="link" href="Lesson_7_Putting_It_All_Together_Visual_LISP_IDE.html">
      Lesson 7: Putting It All Together (Visual LISP IDE)
     </a>
    </div>
    <div class="previouslink">
     <strong>
      Previous topic:
     </strong>
     <a class="link" href="Handling_Nonlinear_Reactor_Sequences.html">
      Handling Nonlinear Reactor Sequences
     </a>
    </div>
    <div class="nextlink">
     <strong>
      Next topic:
     </strong>
     <a class="link" href="Updating_Gp_Calculate_and_Draw_Tiles.html">
      Updating Gp:Calculate-and-Draw-Tiles
     </a>
    </div>
   </div>
  </div>
 </body>
</html>
