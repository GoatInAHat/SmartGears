<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
  <meta content="concept" name="topic-type"/>
  <meta content="/view/OARX/2025/ENU/" name="helpsystempath"/>
  <meta content="OARX" name="product"/>
  <meta content="2025" name="release"/>
  <meta content="Developer" name="book"/>
  <meta content="AutoCAD-AutoLISP-Tutorials" name="component"/>
  <meta content="25/4/2024" name="created"/>
  <meta content="ACD=2025" name="applies-to"/>
  <meta content="ACAD_E=2025" name="applies-to"/>
  <meta content="AMECH_PP=2025" name="applies-to"/>
  <meta content="ARCHDESK=2025" name="applies-to"/>
  <meta content="BLDSYS=2025" name="applies-to"/>
  <meta content="CIV3D=2025" name="applies-to"/>
  <meta content="MAP=2025" name="applies-to"/>
  <meta content="PLNT3D=2025" name="applies-to"/>
  <meta content="PNID=2025" name="applies-to"/>
  <meta content="STRDET=2025" name="applies-to"/>
  <meta content="UTLDESN=2025" name="applies-to"/>
  <meta content="CSY, DEU, ESP, FRA, HUN, ITA, KOR, PLK, PTB, RUS, CHS, CHT" name="applies-to-languages"/>
  <meta content="TRIDION" name="generatedby"/>
  <meta content="disable" name="user-comments"/>
  <meta content="GUID-EA2B760C-866D-46BB-B682-EEC46C8FF11B" name="workflow-parent-id"/>
  <meta content="general" name="experiencelevel"/>
  <meta content="programmer" name="audience"/>
  <meta content="03/12/2019" name="modified"/>
  <meta content="autolisp" name="topic-subtype"/>
  <meta content="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC" name="topicid"/>
  <meta content="ENU" name="language"/>
  <title>
   Updating the C:GPath Function
  </title>
  <link href="../../../../_assets/client-28da4093.css" rel="stylesheet" type="text/css"/>
 </head>
 <body id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC">
  <div class="head">
   <div class="head-block">
    <div class="button-info">
     <span id="infoline">
     </span>
    </div>
    <div class="ancestry">
    </div>
    <div class="head-text">
     <h1>
      Updating the C:GPath Function
     </h1>
    </div>
   </div>
  </div>
  <div class="body conbody">
   <div class="section" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__GUID-98CBFA1F-2E21-47BF-9D58-A9BE2F9255DA">
    <p class="p" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__WSFACF1429558A55DE1929BBDFEF458CE1C-76E5">
     Update the
     <samp class="ph codeph" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__GUID-40796CA6-14F0-46E3-9932-9878E0525784">
      C:GPath
     </samp>
     function by adding reactor creation logic.
    </p>
   </div>
   <div class="section" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__WSFACF1429558A55DE6C92BAFEE30F7510-7DE3">
    <h2 class="title sectiontitle">
     To add reactor creation logic to C:GPath
    </h2>
    <ol class="ol" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__WS1A9193826455F5FF18CB41610EC0A2E719-73DC">
     <li class="li" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__WS1A9193826455F5FF-7F10494411F03A24F24-1D52">
      Replace your version of
      <em class="ph i" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__GUID-980E8DFB-5398-41D7-8E4A-585D07FB3F97">
       gpmain.lsp
      </em>
      with the updated version shown below. Copy this code from the
      <em class="ph i" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__GUID-FFE7A8F4-F3D3-4492-997A-58F1F1F577C5">
       &lt;AutoCAD directory&gt;\Tutorial\VisualLISP\Lesson6
      </em>
      directory:
      <pre class="pre codeblock prettyprint">
(defun C:GPath (/
        gp_PathData
        gp_dialogResults
        PolylineName
        tileList
           )
  (setvar "OSMODE" 0)              ;; Turn off object snaps

  ;|
  ;; Lesson 6 adds a stubbed-out command reactor to AutoCAD
  ;; However, it would be undesirable to react to every
  ;; drawing of a circle should the COMMAND tile creation
  ;; method be chosen by the user.  So, disable the 
  ;; *commandReactor* in case it exists. 
  |;
  (if *commandReactor*
    (progn
      (setq *commandReactor* nil)
      (vlr-remove-all :VLR-Command-Reactor)
    )
  )

  ;; Ask the user for input: first for path location and
  ;; direction, then for path parameters.  Continue only if you
  ;; have valid input.  Store the data in gp_PathData.
  (if (setq gp_PathData (gp:getPointInput))
    (if (setq gp_dialogResults
           (gp:getDialogInput
         (cdr (assoc 40 gp_PathData))
           ) ;_ end of gp:getDialogInput
    ) ;_ end of setq
    
    (progn
      ;; Now take the results of gp:getPointInput and append this to
      ;; the added information supplied by gp:getDialogInput
      (setq gp_PathData (append gp_PathData gp_DialogResults))

      ;; At this point, you have all the input from the user
      ;; Draw the outline, storing the resulting polyline "pointer"
      ;; in the variable called PolylineName
      (setq PolylineName (gp:drawOutline gp_PathData))

      ;; Next, it is time to draw the tiles within the boundary.
      ;; The gp_tileList contains a list of the object pointers for
      ;; the tiles.  By counting up the number of points (using the
      ;; length function), we can print out the results of how many
      ;; tiles were drawn.
      (princ "\nThe path required ")
      (princ
        (length
          (setq tileList (gp:Calculate-and-Draw-Tiles gp_PathData))
        ) ;_ end of length
      ) ;_ end of princ
      (princ " tiles.")

      ;; Add the list of pointers to the tiles (returned by
      ;; gp:Calculate-and-Draw-Tiles) to gp_PathData. This will
      ;; be stored in the reactor data for the reactor attached 
      ;; to the boundary polyline.  With this data, the polyline
      ;; "knows" what tiles (circles) belong to it.
      (setq gp_PathData
             (append (list (cons 100 tileList))
                      ; all the tiles
                 gp_PathData
             ) ;_ end of append
      ) ;_ end of setq

      ;; Before we attach reactor data to an object, let's look at
      ;; the function vlr-object-reactor
      ;; vlr-object-reactor has the following arguments:
      ;;  (vlr-object-reactor owner's data callbacks)
      ;;      The callbacks Argument is a list comprised
      ;;      '(event_name . callback_function)
      ;;
      ;; For this exercise we will use all arguments
      ;; associated with vlr-object-reactor
      ;; These reactor functions will execute only if
      ;; the polyline in PolylineName is modified or erased
      (vlr-object-reactor
        ;; The first argument for vlr-object-reactor is
        ;; the "Owner's List" argument.  This is where to
        ;; place the object to be associated with the
        ;; reactor.  In this case, it is the vlaObject
        ;; stored in PolylineName.
        (list PolylineName)

        ;; The second argument contains the data for the path
        gp_PathData

        ;; The third argument is the list of specific reactor
        ;; types that we are interested in using
        '
         (
          ;; reactor that is called upon modification of the object
          (:vlr-modified . gp:outline-changed)
          ;; reactor that is called upon erasure of the object
          (:vlr-erased . gp:outline-erased)
         )
      ) ;_ end of vlr-object-reactor
      ;; Next, register a command reactor to adjust the polyline
      ;; when the changing command is finished
      (if (not *commandReactor*)
        (setq *commandReactor*
          (VLR-Command-Reactor
             nil          ; No data is associated with the command reactor
             '(
               (:vlr-commandWillStart . gp:command-will-start)
               (:vlr-commandEnded . gp:command-ended)
              )
           ) ;_ end of vlr-command-reactor
        )
      )

      ;; The following code removes all reactors when the drawing is
      ;; closed. This is extremely important!!!!!!!!!
      ;; Without this notification, AutoCAD may crash upon exiting!
      (if (not *DrawingReactor*)
           (setq *DrawingReactor*
           (VLR-DWG-Reactor
                nil          ; No data is associated with the drawing reactor
                '((:vlr-beginClose . gp:clean-all-reactors)
                 )
              ) ;_ end of vlr-DWG-reactor
          )
        )
    ) ;_ end of progn
    (princ "\nFunction cancelled.")
  ) ;_ end of if

  (princ "\nIncomplete information to draw a boundary.")
  ) ;_ end of if

  (princ)               ; exit quietly
) ;_ end of defun

;;; Display a message to let the user know the command name.
(princ "\nType GPATH to draw a garden path.")
(princ)</pre>
     </li>
     <li class="li" id="GUID-E133F06A-FA83-4D38-B34F-EB7100F92ACC__WS1A9193826455F5FF-7F10494411F03A24F24-1D51">
      Review the code modifications and comments describing what each new statement does. This tutorial shows all modified code in boldface.
     </li>
    </ol>
   </div>
  </div>
  <div class="related-links">
   <div class="familylinks">
    <div class="parentlink">
     <strong>
      Parent topic:
     </strong>
     <a class="link" href="Lesson_6_Acting_With_Reactors_Visual_LISP_IDE.html">
      Lesson 6: Acting With Reactors (Visual LISP IDE)
     </a>
    </div>
    <div class="previouslink">
     <strong>
      Previous topic:
     </strong>
     <a class="link" href="Storing_Data_With_a_Reactor.html">
      Storing Data With a Reactor
     </a>
    </div>
    <div class="nextlink">
     <strong>
      Next topic:
     </strong>
     <a class="link" href="Adding_Reactor_Callback_Functions.html">
      Adding Reactor Callback Functions
     </a>
    </div>
   </div>
  </div>
 </body>
</html>
